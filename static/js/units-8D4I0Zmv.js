import{j as y}from"./rainbowkit-BebTHc3A.js";import{S as M}from"./useManageContract-BX9BE4dC.js";const $=({min:r=5,max:t=35,step:e,value:i=0,minPrice:n=0,maxPrice:s=0,onChange:o})=>{const u=a=>{const x=a/100;o&&o(x)};return y.jsxs("div",{className:"flex-1 flex items-center progress",children:[y.jsxs("div",{className:"mr-[14px]",children:[n,"ETH"]})," ",y.jsx(M,{className:"flex-1 progress_slider",min:r*100,max:t*100,step:e,value:i*100,onChange:u,tipFormatter:a=>`${a}%`,tooltip:{open:!0}}),y.jsxs("div",{className:"ml-[14px]",children:[s," ETH"]})]})},G=$,v="6.11.1";function S(r,t,e){for(let i in t){let n=t[i];Object.defineProperty(r,i,{enumerable:!0,value:n,writable:!1})}}function m(r){if(r==null)return"null";if(Array.isArray(r))return"[ "+r.map(m).join(", ")+" ]";if(r instanceof Uint8Array){const t="0123456789abcdef";let e="0x";for(let i=0;i<r.length;i++)e+=t[r[i]>>4],e+=t[r[i]&15];return e}if(typeof r=="object"&&typeof r.toJSON=="function")return m(r.toJSON());switch(typeof r){case"boolean":case"symbol":return r.toString();case"bigint":return BigInt(r).toString();case"number":return r.toString();case"string":return JSON.stringify(r);case"object":{const t=Object.keys(r);return t.sort(),"{ "+t.map(e=>`${m(e)}: ${m(r[e])}`).join(", ")+" }"}}return"[ COULD NOT SERIALIZE ]"}function L(r,t,e){let i=r;{const s=[];if(e){if("message"in e||"code"in e||"name"in e)throw new Error(`value will overwrite populated values: ${m(e)}`);for(const o in e){if(o==="shortMessage")continue;const u=e[o];s.push(o+"="+m(u))}}s.push(`code=${t}`),s.push(`version=${v}`),s.length&&(r+=" ("+s.join(", ")+")")}let n;switch(t){case"INVALID_ARGUMENT":n=new TypeError(r);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":n=new RangeError(r);break;default:n=new Error(r)}return S(n,{code:t}),e&&Object.assign(n,e),n.shortMessage==null&&S(n,{shortMessage:i}),n}function l(r,t,e,i){if(!r)throw L(t,e,i)}function f(r,t,e,i){l(r,t,"INVALID_ARGUMENT",{argument:e,value:i})}["NFD","NFC","NFKD","NFKC"].reduce((r,t)=>{try{if("test".normalize(t)!=="test")throw new Error("bad");if(t==="NFD"&&"é".normalize("NFD")!=="é")throw new Error("broken");r.push(t)}catch{}return r},[]);function _(r,t,e){if(r!==t){let i=e,n="new";i+=".",n+=" "+e,l(!1,`private constructor; use ${i}from* methods`,"UNSUPPORTED_OPERATION",{operation:n})}}function j(r,t,e){if(r instanceof Uint8Array)return r;if(typeof r=="string"&&r.match(/^0x([0-9a-f][0-9a-f])*$/i)){const i=new Uint8Array((r.length-2)/2);let n=2;for(let s=0;s<i.length;s++)i[s]=parseInt(r.substring(n,n+2),16),n+=2;return i}f(!1,"invalid BytesLike value",t,r)}function k(r,t){return j(r,t)}const R=BigInt(0),w=BigInt(1),p=9007199254740991;function B(r,t){const e=C(r,"value"),i=BigInt(I(t,"width"));if(l(e>>i===R,"overflow","NUMERIC_FAULT",{operation:"fromTwos",fault:"overflow",value:r}),e>>i-w){const n=(w<<i)-w;return-((~e&n)+w)}return e}function A(r,t){const e=C(r,"value"),i=BigInt(I(t,"bits"));return e&(w<<i)-w}function F(r,t){switch(typeof r){case"bigint":return r;case"number":return f(Number.isInteger(r),"underflow",t||"value",r),f(r>=-p&&r<=p,"overflow",t||"value",r),BigInt(r);case"string":try{if(r==="")throw new Error("empty string");return r[0]==="-"&&r[1]!=="-"?-BigInt(r.substring(1)):BigInt(r)}catch(e){f(!1,`invalid BigNumberish string: ${e.message}`,t||"value",r)}}f(!1,"invalid BigNumberish value",t||"value",r)}function C(r,t){const e=F(r,t);return l(e>=R,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:r}),e}const T="0123456789abcdef";function V(r){if(r instanceof Uint8Array){let t="0x0";for(const e of r)t+=T[e>>4],t+=T[e&15];return BigInt(t)}return F(r)}function I(r,t){switch(typeof r){case"bigint":return f(r>=-p&&r<=p,"overflow",t||"value",r),Number(r);case"number":return f(Number.isInteger(r),"underflow",t||"value",r),f(r>=-p&&r<=p,"overflow",t||"value",r),r;case"string":try{if(r==="")throw new Error("empty string");return I(BigInt(r),t)}catch(e){f(!1,`invalid numeric string: ${e.message}`,t||"value",r)}}f(!1,"invalid numeric value",t||"value",r)}const O=BigInt(-1),c=BigInt(0),b=BigInt(1),D=BigInt(5),d={};let N="0000";for(;N.length<80;)N+=N;function g(r){let t=N;for(;t.length<r;)t+=t;return BigInt("1"+t.substring(0,r))}function U(r,t,e){const i=BigInt(t.width);if(t.signed){const n=b<<i-b;l(e==null||r>=-n&&r<n,"overflow","NUMERIC_FAULT",{operation:e,fault:"overflow",value:r}),r>c?r=B(A(r,i),i):r=-B(A(-r,i),i)}else{const n=b<<i;l(e==null||r>=0&&r<n,"overflow","NUMERIC_FAULT",{operation:e,fault:"overflow",value:r}),r=(r%n+n)%n&n-b}return r}function E(r){typeof r=="number"&&(r=`fixed128x${r}`);let t=!0,e=128,i=18;if(typeof r=="string"){if(r!=="fixed")if(r==="ufixed")t=!1;else{const s=r.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);f(s,"invalid fixed format","format",r),t=s[1]!=="u",e=parseInt(s[2]),i=parseInt(s[3])}}else if(r){const s=r,o=(u,a,x)=>s[u]==null?x:(f(typeof s[u]===a,"invalid fixed format ("+u+" not "+a+")","format."+u,s[u]),s[u]);t=o("signed","boolean",t),e=o("width","number",e),i=o("decimals","number",i)}f(e%8===0,"invalid FixedNumber width (not byte aligned)","format.width",e),f(i<=80,"invalid FixedNumber decimals (too large)","format.decimals",i);const n=(t?"":"u")+"fixed"+String(e)+"x"+String(i);return{signed:t,width:e,decimals:i,name:n}}function P(r,t){let e="";r<c&&(e="-",r*=O);let i=r.toString();if(t===0)return e+i;for(;i.length<=t;)i=N+i;const n=i.length-t;for(i=i.substring(0,n)+"."+i.substring(n);i[0]==="0"&&i[1]!==".";)i=i.substring(1);for(;i[i.length-1]==="0"&&i[i.length-2]!==".";)i=i.substring(0,i.length-1);return e+i}class h{format;#e;#t;#r;_value;constructor(t,e,i){_(t,d,"FixedNumber"),this.#t=e,this.#e=i;const n=P(e,i.decimals);S(this,{format:i.name,_value:n}),this.#r=g(i.decimals)}get signed(){return this.#e.signed}get width(){return this.#e.width}get decimals(){return this.#e.decimals}get value(){return this.#t}#n(t){f(this.format===t.format,"incompatible format; use fixedNumber.toFormat","other",t)}#i(t,e){return t=U(t,this.#e,e),new h(d,t,this.#e)}#s(t,e){return this.#n(t),this.#i(this.#t+t.#t,e)}addUnsafe(t){return this.#s(t)}add(t){return this.#s(t,"add")}#o(t,e){return this.#n(t),this.#i(this.#t-t.#t,e)}subUnsafe(t){return this.#o(t)}sub(t){return this.#o(t,"sub")}#u(t,e){return this.#n(t),this.#i(this.#t*t.#t/this.#r,e)}mulUnsafe(t){return this.#u(t)}mul(t){return this.#u(t,"mul")}mulSignal(t){this.#n(t);const e=this.#t*t.#t;return l(e%this.#r===c,"precision lost during signalling mul","NUMERIC_FAULT",{operation:"mulSignal",fault:"underflow",value:this}),this.#i(e/this.#r,"mulSignal")}#f(t,e){return l(t.#t!==c,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),this.#n(t),this.#i(this.#t*this.#r/t.#t,e)}divUnsafe(t){return this.#f(t)}div(t){return this.#f(t,"div")}divSignal(t){l(t.#t!==c,"division by zero","NUMERIC_FAULT",{operation:"div",fault:"divide-by-zero",value:this}),this.#n(t);const e=this.#t*this.#r;return l(e%t.#t===c,"precision lost during signalling div","NUMERIC_FAULT",{operation:"divSignal",fault:"underflow",value:this}),this.#i(e/t.#t,"divSignal")}cmp(t){let e=this.value,i=t.value;const n=this.decimals-t.decimals;return n>0?i*=g(n):n<0&&(e*=g(-n)),e<i?-1:e>i?1:0}eq(t){return this.cmp(t)===0}lt(t){return this.cmp(t)<0}lte(t){return this.cmp(t)<=0}gt(t){return this.cmp(t)>0}gte(t){return this.cmp(t)>=0}floor(){let t=this.#t;return this.#t<c&&(t-=this.#r-b),t=this.#t/this.#r*this.#r,this.#i(t,"floor")}ceiling(){let t=this.#t;return this.#t>c&&(t+=this.#r-b),t=this.#t/this.#r*this.#r,this.#i(t,"ceiling")}round(t){if(t==null&&(t=0),t>=this.decimals)return this;const e=this.decimals-t,i=D*g(e-1);let n=this.value+i;const s=g(e);return n=n/s*s,U(n,this.#e,"round"),new h(d,n,this.#e)}isZero(){return this.#t===c}isNegative(){return this.#t<c}toString(){return this._value}toUnsafeFloat(){return parseFloat(this.toString())}toFormat(t){return h.fromString(this.toString(),t)}static fromValue(t,e,i){const n=e==null?0:I(e),s=E(i);let o=F(t,"value");const u=n-s.decimals;if(u>0){const a=g(u);l(o%a===c,"value loses precision for format","NUMERIC_FAULT",{operation:"fromValue",fault:"underflow",value:t}),o/=a}else u<0&&(o*=g(-u));return U(o,s,"fromValue"),new h(d,o,s)}static fromString(t,e){const i=t.match(/^(-?)([0-9]*)\.?([0-9]*)$/);f(i&&i[2].length+i[3].length>0,"invalid FixedNumber string value","value",t);const n=E(e);let s=i[2]||"0",o=i[3]||"";for(;o.length<n.decimals;)o+=N;l(o.substring(n.decimals).match(/^0*$/),"too many decimals for format","NUMERIC_FAULT",{operation:"fromString",fault:"underflow",value:t}),o=o.substring(0,n.decimals);const u=BigInt(i[1]+s+o);return U(u,n,"fromString"),new h(d,u,n)}static fromBytes(t,e){let i=V(k(t,"value"));const n=E(e);return n.signed&&(i=B(i,n.width)),U(i,n,"fromBytes"),new h(d,i,n)}}function z(r,t){let e=18;return e=I(t,"unit"),h.fromValue(r,e,{decimals:e,width:512}).toString()}function H(r,t){f(typeof r=="string","value must be a string","value",r);let e=18;return e=I(t,"unit"),h.fromString(r,{decimals:e,width:512}).value}function K(r){return z(r,18)}function q(r){return H(r,18)}export{G as M,K as f,q as p};
